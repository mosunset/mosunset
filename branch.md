# Merge

複数人が同じリポジトリで複数のブランチを同時に開発し、**「ローカルでの直接 merge」** と **「Pull Request (PR) を使った merge」** の両方のやり方を取り混ぜて進める場合の、**大まかな作業の流れ**を例示します。
実際の手順はチームやプロジェクトのルールによって多少変わりますが、理解の参考になれば幸いです。

# 大まかな前提

-   **main ブランチ**（または master）を安定稼働させておく
-   開発内容ごとに **feature ブランチ** や **topic ブランチ** を作り、そこで作業する
-   コードレビューが必要な場合は **Pull Request** を使ってレビュー～ merge
-   ちょっとした修正などの場合は **ローカルで直接 merge** して push
    ※ ただし必ずしもオススメではなく、基本的には PR merge のほうが履歴管理しやすい

# 具体的な流れ

## 1. リポジトリをクローン / ブランチ運用の準備

1. チーム共有のリポジトリが GitHub (または GitLab 等) にあるとする
2. 各メンバーが `git clone` でローカルへ取得
3. `main` ブランチを最新状態にしておく（`git pull origin main`）

## 2. 新機能・修正ごとにブランチを作成

1. `git checkout -b feature/xxx` のように、新しいブランチ（以下「feature ブランチ」と呼ぶ）を作成
2. feature ブランチ上で開発・コミットを進める
3. 必要に応じて `git push` してリモートにも feature ブランチを作成しておく

ここまでは全員共通です。ここから **「merge のみ」** と **「PR を使う」** という二通りの流れに分岐します。

## A. ローカルで直接 merge する場合

**(1)** ローカルで開発が完了したら、`main` ブランチを最新にしておく

```bash
git checkout main
git pull origin main  # もしくは fetch & merge/pull
```

**(2)** `main` に対して feature ブランチを merge

```bash
git merge feature/xxx
```

-   コンフリクトがあれば手動で解消し、再度ステージ & コミット

**(3)** merge が完了したらリモートへ push

```bash
git push origin main
```

-   これでリモートリポジトリの `main` に変更が反映される

**(4)** 使い終わった feature ブランチはローカル・リモートで削除（不要なら）

```bash
git branch -d feature/xxx
git push origin --delete feature/xxx
```

-   ただしチームのルールで「ブランチはアーカイブ的に残す」場合などもあり

### メリット・デメリット

-   **メリット**
    -   すぐに merge できる。簡単。
    -   小規模修正や緊急修正などで便利。
-   **デメリット**
    -   コードレビューを挟みにくい。
    -   誰がいつ何のために merge したか履歴が若干わかりにくい（PR に比べると可視化しづらい）。
    -   チームメンバーが多い場合、勝手に merge されると混乱を招く可能性。

## B. Pull Request (PR) を使った merge の場合

**(1)** feature ブランチをリモートに push

```bash
git push origin feature/xxx
```

**(2)** リポジトリホスティングサービス（GitHub など）の画面で、
「Compare & pull request」や「New pull request」を作成

-   ベースブランチ(merge 先) を `main`、比較対象(merge 元) を `feature/xxx` に設定
-   タイトルや本文に、やったこと・背景などを記載

**(3)** Pull Request 上でコードレビューを実施

-   チームメンバーが指摘やコメントをする
-   必要に応じて修正を行い、再度 push すると PR に反映される

**(4)** レビューが完了したら、GitHub 上から `Merge` ボタンを押す

-   `Merge commit` や `Squash and merge` など、チーム方針に沿った方法で merge
-   ※ ここはローカルで `git merge` しなくても、GitHub 上で完結

**(5)** merge が完了したら feature ブランチを削除するかはチームポリシー次第

-   `Delete branch` ボタンが表示されるので押せば削除できる

### メリット・デメリット

-   **メリット**
    -   コードレビューや CI テスト（自動テスト）と連携しやすい
    -   コミット履歴やレビュー履歴が GitHub (GitLab 等) 上に一括管理され、見返しやすい
    -   大人数のチーム開発に向いている
-   **デメリット**
    -   ローカルで直接 merge に比べると手間が増える
    -   小さな変更でも PR を出すフローだと、ややオーバーヘッド

# 実運用上のポイント

1. **基本は PR merge を推奨**

    - チームでの開発・レビューがスムーズになり、履歴の可視化も楽になります
    - 緊急修正などでどうしても手早く対応が必要な場合のみローカル merge にする、という方針にすると管理しやすい

2. **コミットの粒度を揃える**

    - 「1 コミットで膨大な変更を含む」「1 つのファイル編集ごとに細切れコミットを大量にする」などはレビューが大変
    - PR を使う場合も、ローカル merge の場合も、見る側が分かりやすいまとまりでコミットするとスムーズ

3. **コンフリクトを定期的に解消**

    - 長期間ブランチを切り離したままだとコンフリクトが大きくなりがち
    - 適度に `main` の最新を `feature/xxx` に取り込む (fetch/merge あるいは rebase) ことで大きな衝突を回避しやすい

4. **レビューとテストのタイミング**
    - PR の場合は、レビュー前に CI やローカルテストを必ず通す
    - ローカル merge の場合でも「他の人が pull してから動かなくならないか？」を確認してから push する

# まとめ

-   **複数人・複数ブランチ** で開発する際は、**feature ブランチ** ごとに作業し、完了後は **merge** で `main` に取り込むのが基本
-   コードレビューや履歴管理が必要なら、**Pull Request (PR) を利用して merge する** のがおすすめ
-   緊急や小規模修正では、**ローカルで直接 merge** → push という流れを取ることもある
-   ブランチや作業状況を常に最新に保ち、コンフリクトは小まめに解消すると後が楽

上記の流れをベースに、チームの人数や文化、プロジェクト規模に応じて運用を調整してください。
「原則は PR、例外は直接 merge」のようにルールを設けておけば、開発全体が混乱しにくくなるはずです。

# Clone

GitHub やその他のホスティングサービスで運用しているリポジトリを、**他の人が単に `git clone` しただけだとプッシュできない**のはよくあることです。
これは **「そのユーザーにプッシュ（書き込み）権限がない」** ためで、GitHub などではデフォルト設定だとクローンは誰でもできても「プッシュは権限を持つ人のみ」という仕組みになっています。

以下では、この「他の人がプッシュできるようにする」方法をいくつか紹介します。

## 1. **リポジトリにコラボレーター（共同開発者）として招待する**

### GitHub 上での設定例

1. **リポジトリのオーナー**（作成したユーザー、または管理者権限を持つユーザー）が、GitHub 上のリポジトリ画面を開く
2. 画面上部の「Settings」タブをクリック
3. 左メニューの「Collaborators and Teams」あるいは「Manage Access」(GitHub の UI によって変わります)を選択
4. **「Add people」** ボタンなどを押して、プッシュさせたいユーザーの GitHub アカウントを登録
5. 招待を送信し、相手が承諾すると、そのユーザーはリポジトリにプッシュできるようになる

### ポイント

-   リポジトリが **private**（非公開）の場合は、この「招待される」以外の方法で直接 push は基本できません
-   一度コラボレーター（またはチーム）として権限を付与すれば、そのユーザーは `git clone` → `git push` を行えます

## 2. **Fork + Pull Request (オープンソース的な流れ)**

一般的なオープンソース開発では、オーナーではない人は直接プッシュせず、**Fork（自分用に複製）** → **Pull Request**（PR）のやり取りで変更をリポジトリに取り込んでもらうのが普通です。

1. リポジトリを自分のアカウントに **Fork** する
2. Fork した自分のリポジトリを `git clone` する
3. 自分のリポジトリに対して自由に `git push` できる（自分のリポジトリなので権限がある）
4. 変更内容を本家リポジトリに取り込んでもらうために **Pull Request** を作成する
5. リポジトリのオーナーが問題なければマージし、本家側に変更が反映される

### ポイント

-   オーナー側は「誰がどのような変更を提案しているか」分かりやすく管理できる
-   アクセス権限をあまり緩くしなくてもコントロール可能
-   大規模なプロジェクトはほぼこのスタイル

## 3. **組織 (Organization) やチームで権限管理をする**

GitHub の **Organization** 機能を使う場合は、**チーム単位でリポジトリへの書き込み権限**を付与することができます。

1. オーナーが Organization を作成
2. コントリビューターを全員招待して、Organization 内でチームを作成
3. そのチームに **Write (または Maintain/Admin)** 権限を与える
4. チームメンバーは、対象リポジトリに自由に push 可能になる

### ポイント

-   企業や大人数プロジェクトだと、コラボレーター個別登録より便利
-   変更があったときも「チームから外せば権限を失う」という管理がしやすい

## 4. **SSH キーやアクセストークンの設定を確認**

もしコラボレーターとして権限があるのに push できない場合は、以下のような認証関連の問題が考えられます。

1. **SSH キー** が未設定で、GitHub に登録していない
    - `git remote -v` でリモートの URL を確認し、SSH 用 URL を使っている場合はローカル PC と GitHub 両方で SSH 設定が必要
2. **HTTPS でのパーソナルアクセストークン (PAT)** を使っていない
    - GitHub は基本的にパスワードでの push を廃止し、**個人アクセストークン** の使用を推奨(必須)しています
3. **GitHub Desktop** などのクライアント側アプリで認証設定がされていない

> 参考: [GitHub Docs - SSH key を使ったプッシュ](https://docs.github.com/ja/authentication/connecting-to-github-with-ssh)
> 参考: [個人アクセストークン（PAT）の発行と使い方](https://docs.github.com/ja/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token)

## まとめ

1. **「clone するだけ」では書き込み権限(プッシュ権限)がない** → コラボレーターやチームの設定が必要
2. **Fork + Pull Request** という一般的なフローでは、他人のリポジトリに直接プッシュせず開発参加できる
3. 企業や団体レベルであれば、GitHub Organization / チームを活用する
4. 「権限はあるはずなのに push できない」場合は **SSH キー設定やトークン認証** を確認

ローカルへ clone できるのは **読み取り (read) 権限** がある場合ですが、**書き込み (write) 権限** はリポジトリの管理者が付与する必要があります。
それを踏まえてコラボレーター設定 or 組織管理 or Fork 運用をすることで、他のメンバーも自由に push できるようになります。
